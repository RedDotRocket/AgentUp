"""
{{ display_name }} plugin for AgentUp{% if template == "ai" %} with AI capabilities{% endif %}.

{{ description }}
"""

import pluggy
from agent.plugins import CapabilityDefinition, CapabilityContext, CapabilityResult, PluginValidationResult, CapabilityType{% if template == "ai" %}, AIFunction{% endif %}

hookimpl = pluggy.HookimplMarker("agentup")


class Plugin:
    """{% if template == "ai" %}AI-enabled {% else %}Direct routing {% endif %}plugin class for {{ display_name }}."""

    def __init__(self):
        """Initialize the plugin."""
        self.name = "{{ plugin_name }}"
        {% if template == "advanced" %}
        self.services = {}
        self.config = {}
        {% elif template == "ai" %}
        self.llm_service = None
        {% endif %}

    @hookimpl
    def register_capability(self) -> CapabilityDefinition:
        """Register the capability with AgentUp."""
        return CapabilityDefinition(
            id="{{ capability_id }}",
            name="{{ display_name }}",
            version="0.3.0",
            description="{{ description }}",
            capabilities=[CapabilityType.TEXT{% if template == "ai" %}, CapabilityType.AI_FUNCTION{% endif %}],
            tags=["{{ plugin_name }}"{% if template == "ai" %}, "ai", "llm"{% endif %}, "custom"],
            required_scopes=["{{ plugin_name }}:use"],  # Default scope for the plugin
        )

    @hookimpl
    def validate_config(self, config: dict) -> PluginValidationResult:
        """Validate capability configuration."""
        {% if template == "ai" %}# AI capabilities typically don't need much config
        return PluginValidationResult(valid=True)
        {% else %}# Add your validation logic here
        return PluginValidationResult(valid=True)
        {% endif %}

    {% if template == "ai" %}@hookimpl
    def configure_services(self, services: dict) -> None:
        """Configure services for the plugin."""
        # Store LLM service for AI operations
        self.llm_service = services.get("llm")

    {% endif %}

    @hookimpl
    def can_handle_task(self, context: CapabilityContext) -> bool:
        """Check if this capability can handle the task."""
        {% if template == "ai" %}# For AI functions, let the LLM decide
        return True
        {% else %}# Add your capability detection logic here
        # For direct routing, you can check for specific keywords or patterns
        return True
        {% endif %}

    @hookimpl
    def execute_capability(self, context: CapabilityContext) -> CapabilityResult:
        """Execute the capability logic."""
        {% if template == "ai" %}# This is called when the capability is invoked directly
        user_input = self._extract_user_input(context)

        return CapabilityResult(
            content=f"{{ display_name }} is ready to help with: {user_input}",
            success=True,
        )
        {% else %}# Extract user input from the task
        user_input = self._extract_user_input(context)

        # Your direct routing capability logic here
        response = f"Processed by {{ display_name }}: {user_input}"

        return CapabilityResult(
            content=response,
            success=True,
            metadata={"capability": "{{ capability_id }}"},
        )
        {% endif %}

    {% if template == "advanced" %}@hookimpl
    def get_middleware_config(self) -> list[dict]:
        """Request middleware for this capability."""
        return [
            {"type": "rate_limit", "requests_per_minute": 60},
            {"type": "cache", "ttl": 300},
            {"type": "logging", "level": "INFO"},
        ]

    @hookimpl
    def get_state_schema(self) -> dict:
        """Define state schema for stateful operations."""
        return {
            "type": "object",
            "properties": {
                "last_processed": {"type": "string"},
                "process_count": {"type": "integer"},
                "user_preferences": {"type": "object"},
            },
        }

    @hookimpl
    def get_health_status(self) -> dict:
        """Report health status of the plugin."""
        return {
            "status": "healthy",
            "version": "0.4.0",
            "services_available": list(self.services.keys()),
            "config_loaded": bool(self.config),
        }

    {% elif template == "ai" %}@hookimpl
    def get_ai_functions(self) -> list[AIFunction]:
        """Provide AI functions for LLM function calling."""
        return [
            AIFunction(
                name="process_with_{{ capability_id }}",
                description="Process user input with {{ display_name }}",
                parameters={
                    "type": "object",
                    "properties": {
                        "input": {
                            "type": "string",
                            "description": "The input to process",
                        },
                        "options": {
                            "type": "object",
                            "description": "Processing options",
                            "properties": {
                                "mode": {
                                    "type": "string",
                                    "enum": ["fast", "accurate", "balanced"],
                                    "default": "balanced",
                                },
                                "format": {
                                    "type": "string",
                                    "enum": ["text", "json", "markdown"],
                                    "default": "text",
                                },
                            },
                        },
                    },
                    "required": ["input"],
                },
                handler=self._process_function,
            ),
            AIFunction(
                name="analyze_with_{{ capability_id }}",
                description="Analyze data with {{ display_name }}",
                parameters={
                    "type": "object",
                    "properties": {
                        "data": {
                            "type": "string",
                            "description": "The data to analyze",
                        },
                        "analysis_type": {
                            "type": "string",
                            "enum": ["summary", "detailed", "comparison"],
                            "description": "Type of analysis to perform",
                        },
                    },
                    "required": ["data", "analysis_type"],
                },
                handler=self._analyze_function,
            ),
        ]

    async def _process_function(self, task, context: CapabilityContext) -> CapabilityResult:
        """Handle the process AI function."""
        params = context.metadata.get("parameters", {})
        input_text = params.get("input", "")
        options = params.get("options", {})

        mode = options.get("mode", "balanced")
        format_type = options.get("format", "text")

        # Process based on mode
        if mode == "fast":
            result = f"Quick processing of: {input_text[:50]}..."
        elif mode == "accurate":
            result = f"Detailed processing of: {input_text}"
        else:
            result = f"Balanced processing of: {input_text}"

        # Format output
        if format_type == "json":
            import json
            result = json.dumps({"result": result, "mode": mode})
        elif format_type == "markdown":
            result = f"## Processing Result\\n\\n{result}"

        return CapabilityResult(content=result, success=True)

    async def _analyze_function(self, task, context: CapabilityContext) -> CapabilityResult:
        """Handle the analyze AI function."""
        params = context.metadata.get("parameters", {})
        data = params.get("data", "")
        analysis_type = params.get("analysis_type", "summary")

        # Perform analysis based on type
        if analysis_type == "summary":
            result = f"Summary of data ({len(data)} characters): {data[:100]}..."
        elif analysis_type == "detailed":
            result = f"Detailed analysis:\\n- Length: {len(data)} chars\\n- Content: {data}"
        else:  # comparison
            result = f"Comparison analysis not yet implemented for: {data[:50]}..."

        return CapabilityResult(
            content=result,
            success=True,
            metadata={"analysis_type": analysis_type},
        )

    {% endif %}
    def _extract_user_input(self, context: CapabilityContext) -> str:
        """Extract user input from the task context."""
        if hasattr(context.task, "history") and context.task.history:
            last_msg = context.task.history[-1]
            if hasattr(last_msg, "parts") and last_msg.parts:
                return last_msg.parts[0].text if hasattr(last_msg.parts[0], "text") else ""
        return ""
